#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_must_use)]
#![allow(dead_code)]

use ethers::prelude::*;
use ethers::types::{Filter, Log};
use frostgate_sdk::frostmessage::{MessageEvent, FrostMessage, ChainId};
use crate::chainadapter::AdapterError;
use tracing::{debug, info, warn};
use std::sync::Arc;
use tokio::sync::RwLock;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::HashMap;
use uuid::Uuid;

/// Event handler for Ethereum chain events
pub struct EventHandler {
    /// Provider for chain interaction
    provider: Arc<Provider<Http>>,
    
    /// Contract address to monitor
    contract_address: Address,
    
    /// Last processed block
    last_block: Arc<RwLock<Option<U64>>>,
}

impl EventHandler {
    /// Creates a new event handler
    pub fn new(provider: Arc<Provider<Http>>, contract_address: Address) -> Self {
        Self {
            provider,
            contract_address,
            last_block: Arc::new(RwLock::new(None)),
        }
    }

    /// Listens for contract events
    pub async fn listen_for_events(&self) -> Result<Vec<MessageEvent>, AdapterError> {
        debug!("Listening for contract events at {:?}", self.contract_address);

        // Get current block
        let current_block = self.provider.get_block_number().await
            .map_err(|e| AdapterError::Network(format!("Failed to get block number: {}", e)))?;

        // Get last processed block
        let mut last_block = self.last_block.write().await;
        let from_block = last_block.unwrap_or(current_block.saturating_sub(U64::from(100)));
        
        // Create filter for FrostMessage events
        let filter = Filter::new()
            .from_block(from_block)
            .to_block(current_block)
            .address(self.contract_address)
            .event("FrostMessage(address,uint256,uint256,bytes,uint256,uint256)");

        // Get matching logs
        let logs = self.provider.get_logs(&filter).await
            .map_err(|e| AdapterError::Network(format!("Failed to get logs: {}", e)))?;

        // Parse logs into events
        let mut events = Vec::new();
        for log in logs {
            if let Ok(event) = self.parse_frost_message_event(log) {
                events.push(event);
            }
        }

        // Update last processed block
        *last_block = Some(current_block);

        debug!("Retrieved {} events", events.len());
        Ok(events)
    }

    /// Parse a FrostMessage event from a log
    fn parse_frost_message_event(&self, log: Log) -> Result<MessageEvent, AdapterError> {
        // Expected event signature: FrostMessage(address sender, uint256 fromChain, uint256 toChain, bytes payload, uint256 nonce, uint256 timestamp)
        let topics = log.topics;
        if topics.len() != 4 {
            return Err(AdapterError::InvalidMessage("Invalid number of topics".into()));
        }

        // Parse indexed parameters from topics
        let sender = Address::from_slice(&topics[1].as_bytes()[12..]);
        
        // Parse data fields
        let data = log.data.to_vec();
        if data.len() < 192 {
            return Err(AdapterError::InvalidMessage("Invalid data length".into()));
        }

        // Parse chain IDs and other parameters
        let from_chain_id = U256::from_big_endian(&data[0..32]).as_u64();
        let to_chain_id = U256::from_big_endian(&data[32..64]).as_u64();
        let payload = data[64..128].to_vec();
        let nonce = U256::from_big_endian(&data[128..160]).as_u64();
        let timestamp = U256::from_big_endian(&data[160..192]).as_u64();

        // Convert chain IDs
        let from_chain = ChainId::try_from(from_chain_id)
            .map_err(|_| AdapterError::InvalidMessage("Invalid source chain ID".into()))?;
        let to_chain = ChainId::try_from(to_chain_id)
            .map_err(|_| AdapterError::InvalidMessage("Invalid target chain ID".into()))?;

        // Create metadata
        let mut metadata = HashMap::new();
        metadata.insert("sender".to_string(), format!("{:?}", sender));

        // Create the message
        let message = FrostMessage {
            id: Uuid::new_v4(),
            from_chain,
            to_chain,
            payload,
            proof: None, // Will be generated by prover
            timestamp,
            nonce,
            signature: None, // Will be added by relayer
            fee: Some(0), // Fee will be set by relayer
            metadata: Some(metadata),
        };

        // Create the event
        Ok(MessageEvent {
            message,
            tx_hash: Some(log.transaction_hash.unwrap_or_default().as_bytes().to_vec()),
            block_number: log.block_number.map(|n| n.as_u64()),
        })
    }

    /// Verifies a message proof on-chain
    pub async fn verify_proof(&self, event: &MessageEvent) -> Result<(), AdapterError> {
        info!("Verifying event proof for message {:?}", event.message.id);

        // TODO: Implement actual on-chain proof verification
        // This would involve:
        // 1. Getting the block containing the event
        // 2. Verifying the event exists in the block
        // 3. Verifying block finality
        // 4. Verifying event parameters match

        // Get transaction receipt
        if let Some(tx_hash) = event.tx_hash.as_ref().and_then(|h| {
            if h.len() == 32 {
                Some(H256::from_slice(h))
            } else {
                None
            }
        }) {
            let receipt = self.provider.get_transaction_receipt(tx_hash).await
                .map_err(|e| AdapterError::Network(format!("Failed to get receipt: {}", e)))?;

            if let Some(receipt) = receipt {
                if receipt.status == Some(U64::from(1)) {
                    // Transaction was successful
                    Ok(())
                } else {
                    Err(AdapterError::InvalidMessage("Transaction failed".into()))
                }
            } else {
                Err(AdapterError::InvalidMessage("Transaction not found".into()))
            }
        } else {
            Err(AdapterError::InvalidMessage("Invalid transaction hash".into()))
        }
    }
}